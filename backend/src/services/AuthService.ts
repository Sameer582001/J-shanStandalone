import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { query } from '../config/db.js';
import { NotificationService } from './NotificationService.js';

const JWT_SECRET = process.env.JWT_SECRET || 'default_secret_change_me';
const notificationService = new NotificationService();

export class AuthService {

    async sendOtp(email: string) {
        // 1. Generate 6-digit OTP
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

        // 2. Save/Update in DB
        // Using upsert logic: try insert, on conflict update
        // Check if exists first for simplicity given standard SQL
        const check = await query('SELECT email FROM EmailVerifications WHERE email = $1', [email]);
        if (check.rows.length > 0) {
            await query('UPDATE EmailVerifications SET code = $1, expires_at = $2, created_at = CURRENT_TIMESTAMP WHERE email = $3', [code, expiresAt, email]);
        } else {
            await query('INSERT INTO EmailVerifications (email, code, expires_at) VALUES ($1, $2, $3)', [email, code, expiresAt]);
        }

        // 3. Send Email
        await notificationService.sendOtpEmail(email, code);
        return { message: 'OTP sent successfully' };
    }

    async register(data: any, skipOtp: boolean = false) {
        let { fullName, email, mobile, password, otp } = data;

        // 0. Verify OTP (if not skipped)
        if (!skipOtp) {
            if (!otp) {
                throw new Error('OTP is required');
            }
            const otpCheck = await query('SELECT code, expires_at FROM EmailVerifications WHERE email = $1', [email]);
            if (otpCheck.rows.length === 0 || otpCheck.rows[0].code !== otp) {
                throw new Error('Invalid OTP');
            }
            if (new Date() > new Date(otpCheck.rows[0].expires_at)) {
                throw new Error('OTP expired');
            }
        }

        // 1. Check if user exists (by mobile or email)
        const userCheck = await query('SELECT id FROM Users WHERE mobile = $1 OR email = $2', [mobile, email]);
        if (userCheck.rows.length > 0) {
            throw new Error(`User already exists (Mobile or Email): ${mobile} / ${email}`);
        }

        // 2. FORCE Auto-Generate Password (User request: "should not manually enter")
        // Always overwrite any provided password with a generated one to ensure "helper" doesn't know it.
        const cleanName = fullName.replace(/\s+/g, '').substring(0, 4);
        const randomDigits = Math.floor(1000 + Math.random() * 9000);
        password = `${cleanName}@${randomDigits}`;
        let autoGeneratedPassword = password;
        console.log(`[AuthService] Force-Generated password for ${email}: ${password}`);

        // 3. Create User
        const hashedPassword = await bcrypt.hash(password, 10);
        const authId = `AUTH-${Date.now()}`; // Placeholder for external auth ID
        const userRes = await query(
            'INSERT INTO Users (auth_id, full_name, email, mobile, password_hash) VALUES ($1, $2, $3, $4, $5) RETURNING id',
            [authId, fullName, email, mobile, hashedPassword]
        );
        const userId = userRes.rows[0].id;

        // 4. Send Notification (with password if generated or requested)
        // We always send the password in the welcome email for clarity if it was just created, 
        // or we can strictly only send it if auto-generated.
        // Let's send it if auto-generated.
        await notificationService.sendWelcomeEmail(email, fullName, mobile, autoGeneratedPassword || undefined);

        // 5. Cleanup OTP
        if (!skipOtp) {
            await query('DELETE FROM EmailVerifications WHERE email = $1', [email]);
        }

        return { userId, message: 'User registered successfully. check email for credentials.' };
    }

    async login(mobile: string, password: string) {
        const res = await query('SELECT * FROM Users WHERE mobile = $1', [mobile]);
        if (res.rows.length === 0) {
            throw new Error('User not found');
        }

        const user = res.rows[0];
        const valid = await bcrypt.compare(password, user.password_hash);
        if (!valid) {
            throw new Error('Invalid password');
        }

        console.log('Login: Generating token with secret:', JWT_SECRET.substring(0, 5) + '...');
        const token = jwt.sign({ id: user.id, role: user.role }, JWT_SECRET, { expiresIn: '1h' });
        return { token, user: { id: user.id, mobile: user.mobile, role: user.role } };
    }
}
